
```
多线程共享变量的情况下，为了保证数据的一致性，往往需要对这些变量的访问进行加锁，
而锁的本身又会带来一些问题和开销。  

Immutable Object模式使得我们可以在不使用锁的情况下，既保证共享变量访问的线程安全
，又能避免引入锁可能带来的问题和开销。    

多线程环境下，一个对象常常会被多个线程共享。这种情况下，如果存在多个线程并发地
修改该对象的状态或者一个线程访问该对象的状态而另外一个线程试图修改该对象的状态，

我们不得不做一些同步访问控制以保证数据一致性。而这些同步访问控制，
如显式锁和CAS操作，会带来额外的开销和问题，如上下文切换，等待时间和ABA问题等。

Immutable Object模式的意图是通过使用对外可见的状态不可变的对象，
使得被共享对象"天生"具有线程安全性，而无须额外地同步访问控制。

从而既保证了数据一致性，又避免了同步访问控制所产生的额外开销和问题，也简化了编程。
所谓状态不可变的对象，即对象一经创建，其对外可见的状态就保持不变，

例如Java中的String和Integer。这点固然容易理解，
但还不足以知道我们在实际工作中运用Immutable Object模式。



Client           ImmutableObject       Manipulator

ImmutableObject :负责存储一组不可变状态。
该参与者不对外暴露任何可以修改其状态的方法，其主要方法及职责如下。
一个严格意义上不可变对象要满足以下所有条件。

１.类本身使用final修饰:防止其子类改变其定义的行为。

2. 所有字段都是用final修饰的:使用final修饰不仅仅是从语义上说明所修饰字段的引用
不可改变。更重要的是这个语义在多线程环境下由JMM保证了被修饰字段所引用对象的初始化
安全，即final修饰的字段在其他线程可见时,它必定是初始化完成的。
相反,非final修饰的字段由于缺少这种保证,可能导致一个线程"看到"一个字段的时候，
它还没有被初始化完成，从而可能导致一些不可预料的结果。

3.在对象的创建过程中,this关键字没有泄露给其他类:防止其他类在对象创建过程中
修改其状态。

４．任何字段,若其引用了其他状态可变的对象(如集合,数组等),则这些字段必须是
private修饰的，并且这些字段值不能对外暴露。
若其相关方法要返回这些字段值，应该进行防御性复制

Immutable Object模式特别适用于以下场景。

(1)被建模对象的状态变化不频繁
正如本章案例所展示的,这种场景下可以设置一个专门的线程(Manipulator参与者所在的
线程)用于在被建模对象状态变化时创建新的不可变对象。而其他线程则只是读取不可变对象
的状态。此场景下的一个小技巧是Manipulator对不可变对象的引用采用volatile关键字修饰，
既可以避免使用显示锁(synchronized),又可以保证多线程间的内存可见性。

(2)同时对一组相关的数据进行写操作，因此需要保证原子性：
此场景为了保证操作的原子性，通常的做法是使用显示锁。
但若采用Immutable Object模式，将这一组相关的数据"组合"成一个不可变对象，
则对这一组数据的操作就可以无须加显示锁也能保证原子性，这及简化了编程，
有提高了代码运行效率。本章开头所举的车辆位置跟踪的例子正是这种场景。

(3)使用某个对象作为安全的HashMap的Key:我们知道，
一个对象作为HashMap的key被"放入"HashMap之后，如该对象状态变化导致了其Hash 
Code的变化，则会导致后面在用同样的对象作为key去get的时候无法获取关联的值,
尽管该HashMap中的确存在以该对象为key的条目，相反，
由于不可变对象的状态不变，因此其Hash Code也不变。
这使得不可变对象非常适于用作HashMap的Key.


Guarded Suspension模式的核心是一个受保护方法。
该方法执行其所要真正执行的操作时需要满足特定的条件(Predicate,以下称之为保护条件)
。当该条件不满足时,执行受保护方法的线程会被挂起进入等待状态，
直达该条件满足时该线程才会继续运行。此时，受保护方法才会真正执行其所要执行的操作。
为方便起见，以下称受保护方法所要真正执行的操作为目标动作。


告警功能模块。

该模块的主要功能是将其接受到的告警信息发送给告警服务器。

该模块中的类AlarmAgent负责与告警服务器进行对接。

AlarmAgent的sendAlarm方法负责通过网络连接(Socket连接)将告警信息发送到告警服务器。

AlarmAgent创建了一个专门的线程用于其与告警服务器建立网路连接。
因此，sendAlarm方法被调用的时候,
连接线程可能还没有完成网络连接的建立。
此时,sendAlarm方法应该等待连接线程建立好网络连接。


另外，即便连接线程建立好了网络连接，中途也可能由于某些原因出现
与告警服务器断连的情况。此时,sendAlarm方法需要等待心跳(Heartbeat)任务重新建立好
连接才能上报告警信息。也就是说,sendAlarm方法必须在AlarmAgent与告警服务器
的网络连接建立成功的情况下才能执行其所要执行的操作。

若AlarmAgent与告警服务器的连接未建立(或者连接中断)，
sendAlarm方法的执行线程应该暂挂直到连接建立完毕(或者恢复)
```
## Java并发包学习
### 解密ThreadLocal
```
    ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对
独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。
    可以总结为一句话:ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数
或者组件之间一些公共变量的传递的复杂度。 
    举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这
两个函数都需要同一个东西:公交卡(北京公交和地铁都使用公交卡)，那么我为了不向这两个函数都传递公交卡这个变量(相当于不是一直
带着公交卡上路)，我可以这么做:将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡(当然每次拿的都是同一张公交
卡)。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。
    有人要说了:你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗?但是如果有很多个人(很多个线程)呢?大家可
不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷:提供线
程内部的局部变量，在本线程内随时随地可取，隔离其他线程。            
```