多线程共享变量的情况下，为了保证数据的一致性，往往需要对这些变量的访问进行加锁，而锁的本身又会带来一些问题和开销。
Immutable Object模式使得我们可以在不使用锁的情况下，既保证共享变量访问的线程安全，又能避免引入锁可能带来的问题
和开销。
多线程环境下，一个对象常常会被多个线程共享。这种情况下，如果存在多个线程并发地修改该对象的状态或者一个线程访问该
对象的状态而另外一个线程试图修改该对象的状态，我们不得不做一些同步访问控制以保证数据一致性。而这些同步访问控制，如
显式锁和CAS操作，会带来额外的开销和问题，如上下文切换，等待时间和ABA问题等。Immutable Object模式的意图是通过使用
对外可见的状态不可变的对象，使得被共享对象"天生"具有线程安全性，而无须额外地同步访问控制。从而既保证了数据一致性，又
避免了同步访问控制所产生的额外开销和问题，也简化了编程。
所谓状态不可变的对象，即对象一经创建，其对外可见的状态就保持不变，例如Java中的String和Integer。这点固然容易理解，但
还不足以知道我们在实际工作中运用Immutable Object模式。

Client           ImmutableObject       Manipulator

ImmutableObject :负责存储一组不可变状态。该参与者不对外暴露任何可以修改其状态的方法，其主要方法及职责如下。
一个严格意义上不可变对象要满足以下所有条件。
１.类本身使用final修饰:防止其子类改变其定义的行为。
2. 所有字段都是用final修饰的:使用final修饰不仅仅是从语义上说明所修饰字段的引用不可改变。更重要的是这个语义在多线程环境下
由JMM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程可见时,它必定是初始化完成的。相反,非final修饰
的字段由于缺少这种保证,可能导致一个线程"看到"一个字段的时候，它还没有被初始化完成，从而可能导致一些不可预料的结果。
3.在对象的创建过程中,this关键字没有泄露给其他类:防止其他类在对象创建过程中修改其状态。
４．任何字段,若其引用了其他状态可变的对象(如集合,数组等),则这些字段必须是private修饰的，并且这些字段值不能对外暴露。
若其相关方法要返回这些字段值，应该进行防御性复制
