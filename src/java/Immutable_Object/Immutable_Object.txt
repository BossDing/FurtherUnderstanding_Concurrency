多线程共享变量的情况下，为了保证数据的一致性，往往需要对这些变量的访问进行加锁，而锁的本身又会带来一些问题和开销。
Immutable Object模式使得我们可以在不使用锁的情况下，既保证共享变量访问的线程安全，又能避免引入锁可能带来的问题
和开销。
多线程环境下，一个对象常常会被多个线程共享。这种情况下，如果存在多个线程并发地修改该对象的状态或者一个线程访问该
对象的状态而另外一个线程试图修改该对象的状态，我们不得不做一些同步访问控制以保证数据一致性。而这些同步访问控制，如
显式锁和CAS操作，会带来额外的开销和问题，如上下文切换，等待时间和ABA问题等。Immutable Object模式的意图是通过使用
对外可见的状态不可变的对象，使得被共享对象"天生"具有线程安全性，而无须额外地同步访问控制。从而既保证了数据一致性，又
避免了同步访问控制所产生的额外开销和问题，也简化了编程。
所谓状态不可变的对象，即对象一经创建，其对外可见的状态就保持不变，例如Java中的String和Integer。这点固然容易理解，但
还不足以知道我们在实际工作中运用Immutable Object模式。

Client           ImmutableObject       Manipulator

ImmutableObject :负责存储一组不可变状态。该参与者不对外暴露任何可以修改其状态的方法，其主要方法及职责如下。
一个严格意义上不可变对象要满足以下所有条件。
１.类本身使用final修饰:防止其子类改变其定义的行为。
2. 所有字段都是用final修饰的:使用final修饰不仅仅是从语义上说明所修饰字段的引用不可改变。更重要的是这个语义在多线程环境下
由JMM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程可见时,它必定是初始化完成的。相反,非final修饰
的字段由于缺少这种保证,可能导致一个线程"看到"一个字段的时候，它还没有被初始化完成，从而可能导致一些不可预料的结果。
3.在对象的创建过程中,this关键字没有泄露给其他类:防止其他类在对象创建过程中修改其状态。
４．任何字段,若其引用了其他状态可变的对象(如集合,数组等),则这些字段必须是private修饰的，并且这些字段值不能对外暴露。
若其相关方法要返回这些字段值，应该进行防御性复制

Immutable Object模式特别适用于以下场景。
(1)被建模对象的状态变化不频繁
正如本章案例所展示的,这种场景下可以设置一个专门的线程(Manipulator参与者所在的线程)用于在被建模对象状态变化时创建新的不可
变对象。而其他线程则只是读取不可变对象的状态。此场景下的一个小技巧是Manipulator对不可变对象的引用采用volatile关键字修饰，
既可以避免使用显示锁(synchronized),又可以保证多线程间的内存可见性。

(2)同时对一组相关的数据进行写操作，因此需要保证原子性：
此场景为了保证操作的原子性，通常的做法是使用显示锁。但若采用Immutable Object模式，将这一组相关的数据"组合"成一个不可变
对象，则对这一组数据的操作就可以无须加显示锁也能保证原子性，这及简化了编程，有提高了代码运行效率。本章开头所举的车辆位置
跟踪的例子正是这种场景。

(3)使用某个对象作为安全的HashMap的Key:我们知道，一个对象作为HashMap的key被"放入"HashMap之后，如该对象状态变化导致了
其Hash Code的变化，则会导致后面在用同样的对象作为key去get的时候无法获取关联的值,尽管该HashMap中的确存在以该对象为key的
条目，相反，由于不可变对象的状态不变，因此其Hash Code也不变。这使得不可变对象非常适于用作HashMap的Key.









